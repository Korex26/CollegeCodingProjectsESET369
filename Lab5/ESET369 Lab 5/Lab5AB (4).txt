#include <msp430.h>

void LCD_command(unsigned char);
void LCD_write(unsigned char);
void LCD_init(void);

unsigned int adc_raw;
double volts;
int i;

/**
 * main.c
 */
void main(void)
{
    WDTCTL = WDTPW | WDTHOLD;    // stop watchdog timer
    PM5CTL0 &= ~LOCKLPM5;
    ADC12CTL0 = ADC12SHT0_6 | ADC12ON;
    ADC12CTL1 = ADC12SHP;
    ADC12CTL2 = ADC12RES_2;
    ADC12MCTL0 = ADC12INCH_9;
    ADC12IER0 |= ADC12IE0;
    TA1CTL = TASSEL_2 | MC_1 | TACLR; //timer A

    P6DIR |= 0x01;
    P3DIR |= 0xFF;
    P3OUT &= ~0xFF;
    P8DIR |= 0x0E;
    P8OUT |= 0x0E;
    P4SEL1 |= BIT1;
    P4SEL0 |= BIT1;
    TA1CCR0 = 0;
    __enable_interrupt();

    while(1) {
        ADC12CTL0 |= ADC12ENC | ADC12SC;
        volts = (((double)(adc_raw)) / 4095) * 3.3;
        __delay_cycles(5000);
        LCD_init(); //initialize LCD
        LCD_command(0x01); //clear display
        LCD_command(0x00); //put at the first spot
        __delay_cycles(5000);
        LCD_write('N');
        LCD_write('i');
        LCD_write('k');
        LCD_write('e');
        LCD_write('s');
        LCD_write('h');
        LCD_write(' ');
        LCD_write('N');
        LCD_write('a');
        LCD_write('i');
        LCD_write('r');

        LCD_command(0xC0);
        LCD_write('0' + (int)volts);
        LCD_write('.');
        LCD_write('0' + ((int)(volts * 10) % 10));
        LCD_write('0' + ((int)(volts * 100) % 10));

        if (volts < 1.00) {
            TA1CCR0 =0;
            for( i=0; i < 3000; i++){
                if ((TA1CCTL0 & CCIFG) !=0){
                    P6OUT ^= 0x01;
                    TA1CCTL0 &= ~CCIFG;
                        }

            }
        } else if (volts >= 1.00 && volts < 2.00) {
            TA1CCR0 =956;
            for( i=0; i < 3000; i++){
                if ((TA1CCTL0 & CCIFG) !=0){
                    P6OUT ^= 0x01;
                    TA1CCTL0 &= ~CCIFG;
            }

            }
        } else if (volts >= 2.00 && volts < 3.00) {
            TA1CCR0 = 851;
            for( i=0; i < 3000; i++){
                if ((TA1CCTL0 & CCIFG) !=0){
                    P6OUT ^= 0x01;
                    TA1CCTL0 &= ~CCIFG;
            }

            }
        } else if (volts >= 3.00 && volts <= 3.30) {
            TA1CCR0 = 758;
            for( i=0; i < 3000; i++){
                if ((TA1CCTL0 & CCIFG) !=0){
                    P6OUT ^= 0x01;
                    TA1CCTL0 &= ~CCIFG;
            }

            }
        } else {
            TA1CCR0 =0;
            for( i=0; i < 3000; i++){
                if ((TA1CCTL0 & CCIFG) !=0){
                    P6OUT ^= 0x01;
                    TA1CCTL0 &= ~CCIFG;
                        }

            }
        }
}
}
#pragma vector = ADC12_B_VECTOR
__interrupt void ADC12_ISR(void) {
    if ((ADC12IFGR0 & BIT0) != 0) {
        adc_raw = ADC12MEM0;
    }
}

void LCD_command(unsigned char in) {
    P3OUT = in;
    P8OUT &= ~BIT3;
    P8OUT &= ~BIT2;
    P8OUT |= BIT1;
    __delay_cycles(200);
    P8OUT &= ~BIT1;
}

void LCD_write(unsigned char in) {
    P3OUT = in;
    P8OUT |= BIT3;
    P8OUT &= ~BIT2;
    P8OUT |= BIT1;
    __delay_cycles(200);
    P8OUT &= ~BIT1;
}

void LCD_init() {
    P8OUT &= ~BIT1;
    __delay_cycles(15000);
    LCD_command(0x30);
    __delay_cycles(300);
    LCD_command(0x30);
    __delay_cycles(300);
    LCD_command(0x30);
    __delay_cycles(300);
    LCD_command(0x38);
    LCD_command(0x10);
    LCD_command(0x0F);
    LCD_command(0x06);
    LCD_command(0x01);
    __delay_cycles(3000);
}
